/**
2334. 元素值大于变化阈值的子数组

给你一个整数数组 nums 和一个整数 threshold 。

找到长度为 k 的 nums 子数组，满足数组中 每个 元素都 大于 threshold / k 。

请你返回满足要求的 任意 子数组的 大小 。如果没有这样的子数组，返回 -1 。

子数组 是数组中一段连续非空的元素序列。
https://leetcode.cn/problems/subarray-with-elements-greater-than-varying-threshold/description/
*/
/// 先計算每個數字要超過閥值的最小倍數，要連續出現小於等於長度X的倍數
///
/// 倍數陣列 least_multiple [ 2 7 4 3 2 3 8 ]
///
/// 做倍數的單調棧 找到比該倍數陣列 least_multiple[i] 還要大的下標
///
/// 例如  least_multiple[2] = 4 ，下標為1就是左邊界(7>4)，下標6就是右邊界(8>4)
///
/// 當長度(6-1-1 = 4) >= 倍數(least_multiple[2] = 4)時 ,OUTPUT ANSWER
pub struct Solution;
impl Solution {
    pub fn valid_subarray_size(nums: Vec<i32>, threshold: i32) -> i32 {
        let n = nums.len();
        let mut least_multiple: Vec<i32> = vec![0; n];
        let mut left_index = vec![0; n];
        let mut right_index = vec![n - 1; n];
        let mut stack: Vec<usize> = Vec::new(); // 遞減單調棧，紀錄元素下標
        let mut ans = 0;

        for i in 0..n {
            least_multiple[i] = threshold / nums[i] + 1;
            while let Some(&top) = stack.last() {
                if least_multiple[top] < least_multiple[i] {
                    right_index[top] = i - 1;
                    stack.pop();
                } else if least_multiple[top] == least_multiple[i] {
                    left_index[i] = left_index[top];
                    break;
                } else {
                    left_index[i] = top + 1;
                    break;
                }
            }
            stack.push(i);
        }

        // 计算符合長度的答案
        for i in 0..n {
            if (right_index[i] - left_index[i] + 1) as i32 >= least_multiple[i] {
                return least_multiple[i];
            }
        }
        return -1;
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn example() {
        assert_eq!(Solution::valid_subarray_size(vec![1, 3, 4, 3, 1], 6), 3);
        assert_eq!(Solution::valid_subarray_size(vec![6, 5, 6, 5, 8], 7), 2);
        assert_eq!(
            Solution::valid_subarray_size(
                vec![
                    802004, 526012, 757957, 243310, 336124, 392107, 848457, 803125, 717278, 852486,
                    610801, 759260, 72807, 829109, 541803, 636250, 444453, 580149, 868656, 927123,
                    474186, 354523, 264432, 502901, 404597, 712395, 414671, 370171, 844118, 436342,
                    814834, 223136, 241147, 628114, 50190, 303165, 21529, 380855, 415102, 665756,
                    609251, 839401, 147755, 69452, 843840, 913447, 732169, 49180, 511772, 713914,
                    201539, 60494, 461204, 568364, 702691, 319442, 922352, 184092, 243907, 968459,
                    143049, 718846, 182837, 861363, 860650, 968638, 801282, 516775, 532771, 647870,
                    409083, 791685, 915733, 221261, 508832, 768406, 88418, 884339, 904590, 120156,
                    363069, 986042, 90171, 390140, 438122, 936681, 926414, 186991, 544691, 799527,
                    564251, 764831, 214353, 829085, 180620, 397536, 86549, 728013, 659691, 534196,
                    474616, 882189, 276590, 907311, 654637, 655805, 121256, 868286, 661438, 65951,
                    829879, 319639, 423120, 57508, 653691, 185627, 573512, 657657, 85111, 118794,
                    931267, 303261, 52081, 702907, 897650, 574513, 515576, 524929, 274063, 78281,
                    626052, 127623, 155965, 836595, 781293, 22150, 421308, 803448, 652756, 423612,
                    509389, 720333, 207593, 950394, 445218, 421491, 34285, 941325, 329057, 182104,
                    791318, 784413, 563697, 204658, 19810, 319531, 267681, 100503, 773294, 799637,
                    739396, 956008, 111779, 632934, 167024, 22616, 805292, 834536, 409322, 827234,
                    147246, 683958, 23887, 524398, 62834, 645434, 890827, 312685, 300035, 296658,
                    748427, 240125, 862121, 215413, 164406, 662036, 943738, 942985, 620555, 600387
                ],
                4569796
            ),
            18
        );
    }
    #[test]
    fn test_case() {}
}
